<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
<script>
	var nums = [10, 20, 30, 40, 50]
	
	/*
		0번째 변수 : 10
		1번째 변수 : 20
		2번째 변수 : 30
		3번째 변수 : 40
		4번째 변수 : 50
	*/
	
	document.write('<hr>첫번째 방식</hr>')
	for(let i = 0; i < nums.length; i++){
		document.write(`${i}번째 정수: ${nums[i]}<br>`)
	}
	
	document.write('<hr>두번째 방식</hr>')
	for(let idx in nums){
		document.write(`${idx}번째 정수: ${nums[idx]}<br>`)
	}	
	
	/*
	document.write('<hr>세번째 방식</hr>')
	nums.forEach(function(){	//callback형태 취함		//nums에 들어있는 개수n만큼 function을 n번 호출해줘
		//arguments에 element index num이 있음
		document.write(arguments.length)	//3이 5번 찍힘
	})
	*/
	
	document.write('<hr>세번째 방식</hr>')
	nums.forEach(function(element, index, nums){	
		document.write(`${index}번째 정수: ${element}<br>`)
//		document.write(nums + '<br>')
	})
	
//	var copyNums = [...nums]	//전개연산자
	/*
	var copyNums = []
	for(let i in nums){
		copyNums[i] = nums[i] + 100	//깊은 복사를 하긴 할 건데 nums배열의 원소에 100만큼 더한 값을 복사하고 싶음
	}
	*/
	
	
	//nums배열의 요소 개수만큼 호출. 루프를 돎
	/*
	var copyNums = nums.map(function(){		//매핑의 의미를 가짐
		return 'A'		//nums배열의 개수만큼 리턴하는 값으로 배열을 만듦 	
	})
	*/
	
	/*map함수
	반복문으로 요소를 순회(1, 2, 3 순서로)하면서 각 요소를 어떻게 짝지어줄지 알려줍니다.
	map을 실행하는 배열과 결과로 나오는 배열이 다른 객체라는 것입니다. 
	기존 배열을 수정하지 않고 새로운 배열을 만들어냅니다.
	*/
	var copyNums = nums.map(function(element){	
		return element + 100			
	})
	
	document.write('nums: ' + nums + '<br>')
	document.write('copyNums: ' + copyNums + '<br>')
	
	
	//배열에 몇개요소가 있는지 모르는데 그 요소가 가지는 모든 값이 10의 배수인지 확인
	/*
	let bool = true
	for(let data of nums){
		if(data % 10 != 0){
			bool = false;
			break;
		}
	}
	*/
	
	//배열에 몇개요소가 있는지 모르는데 그 요소가 가지는 모든 값이 10의 배수인지 궁금
	//배열의 모든 값이 조건을 만족하면 true, 그렇지 않으면 false 리턴
	let bool = nums.every(function(element, index, nums){
		return element % 10 == 0
	})	
	document.write('every()결과: ' + bool + '<br>')	//true
	
	
	//배열의 원소 중 하나라도 조건을 만족한다면 true, 그렇지 않으면 false 리턴
	bool = nums.some(function(element, index, nums){
		return element % 10 != 0
	})	
	document.write('some()결과: ' + bool + '<br>')	//false
	
	
	/*let s = 0;
	for(let data of nums){
		s += data
	}
	*/

	/*
	nums.reduce(function(){
//		document.write('!')
		console.log(arguments)	//2개씩 연산을 수행하므로 연산을 수행하는 2번째 인자의 인덱스	
	})
	*/
	
	
	//arguments가 4인 이유
	//(누적 값, 현재 값, 인덱스, 모든 요소들)
	//-> 인덱스가 0일 땐 계산해서 기억 하고 있는 값이 없음. 10 이랑 20 계산 전 before가 없음 
	nums.reduce(function() {
		console.log(arguments)
	})
	
	//원소 2개씩 연산을 수행하다가 요소가 1개가 될 때까지 수행
	let sum = nums.reduce(function(before, element, index){
		return before + element		//before은 전에 연산한 값을 의미
	})
	//오른족에서부터 연산을 수행하는 reduceRight()도 존재함
	
	document.write('배열의 총합: ' + sum + '<br>')
	
</script>
</head>
<body>

</body>
</html>