<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
<script>
	
	var person = { 
		'name' : '홍길동', 
		'phone' : '010-1111-2222',
		'toString' : function(){
			let msg = '';
			for(let key in this){
				if((typeof this[key]) != 'function'){
				msg += key + ': ' + this[key] + '<br>';
				}
			}
			msg += '<hr>';
			return msg;
		}
	};
	
	//얕은 복사
//	var person2 = person;	//같은 객체를 참조하고 있다 > 하나의 배열이 변하면 복사한 다른 배열도 변화한다
	
	//깊은 복사
//	var person2 = {};
//	for(let key in person){
//		person2[key] = person[key]
//	}
	
	
	//복사하는 함수를 아예 만들어버리자
	function clone(obj){
		let object = {};
		for(let key in obj){	//기존 배열의 원소를 돌면서 복사할 배열에 원소 하나하나 삽입 
			object[key] = obj[key]
		}
		return object;
	}
	
//	var person2 = clone(person); 
	

	//함수를 만드는 것도 귀찮아
	var person2 = {...person}	//객체도 조금 다른 배열과 같으므로 전개연산자 사용 가능, 깊은 복사
// 	var person2 = {'name' : '홍길동', 'phone' : '010-1111-2222', 'toString' : function() {}}	//요소마다 계속 돌면서 push됨
	/*전개 연산자
	객체가 가지고 있는 요소값을 하나씩 분리해서 사용 
	ex)파라미터로 그냥 배열을 받으면 통째로 넘겨지는데
	전개연산자로 받으면 원소 원소를 따로 받을 수 있음
	*/


	document.write(person.toString())	
	document.write(person2.toString())	
	//만약 객체에서 toString메소드를 따로 정의해주지 않았다면 부모 객체의 메소드를 가져다 쓴다
	//그러면 //[object Object]	//이렇게밖에 안 나옴
	
	//복사 배열 속성값 변경 후
	person2.phone = '010-6666-7777';
	
	//깊은 복사했기 때문에 다른 배열의 변화의 영향을 받지 않는다
	document.write(person.toString())
	document.write(person2.toString())
	
	//참고로 매개변수를 받을 때는 얕은 복사가 발생한다.
	
</script>
</head>
<body>
	
</body>
</html>
